/* Apresentação

- explicar exemplo protocolo, explicar tipo de adversário
- extensão de arquivo
- estrutura do arquivo
- funções providas pelos builtin declarados
- como modelar um protocolo, estrutura da rule, o que são os states,facts,Fr fact, network(Out,In)...
- tipos de variáveis ~ $ # '' (constante)
- fatos lineares e persistentes
- como definir propriedades de segurança (lógica de primeira ordem)
- diferenciar exists-trace de all-traces
*/


// C -> S: aenc(k,pks)
// C <- S: h(k)
// (k == symmetric key, aenc == asym encryption, pks == S public key )


theory FirstExample
begin



// ----------------------------------- Cryptographic primitives declaration --------------------------------------------------



builtins: hashing, asymmetric-encryption

// this give us: h/1 , aenc/2 , adec/2 , pk/1 (retrive public key from private)

// RULE:
// [Premise] --[Action-fact]-> [Conclusion] 

rule Register_key:
    [ Fr(~priv) ] --> [ !PrivKey($A, ~priv), !PubKey($A, pk(~priv)) ] // $A denotes the peer's identity



// ----------------------------------------------- Protocol modeling ---------------------------------------------------------------------



// ------------ ADVERSARY

// retrieve public key (from database, for example)
rule Get_pubkey:
    [ !Pubkey(A, pub) ] --> [ Out(pub) ]

// dynamic compromise of private/long-term key
rule Reveal_privkey:
    [ !Privkey(A, priv) ] --[ PrivReveal(A) ]-> [ Out(priv) ] 

// ------------ CLIENT ROLE

rule Client_1:
    [ Fr(~symkey), !Pubkey($S, pub) ] // Fresh generated symkey , retrive server public key
    -->
    [ Client_1($S, ~symkey), Out(aenc(~symkey, pub)) ] // thread instantiation (use in next steps) , send encrypted message to network

rule Client_2:
    [ Client_1(S, symkey), In(h(k)) ] // Proceed previous thread , receive network data
    --[ SessionKeyClient(S, symkey) ]-> // Denote state where session key was established with server S
    [  ] // End

// ------------ SERVER ROLE 

rule Serv_1:
    [ !PrivKey($S, ~privS), In(request) ] 
    --[ AnswerRequest($S, adec(request, ~privS)) ]->
    [ Out(h(adec(request, ~privS))) ]  // return hash of message


// ----------------------------------------------- Security properties modeling -----------------------------------------------------------------

// It says: it cannot be that a client has set up a session key symkey with a server S and the adversary 
// learned that symkey unless the adversary performed a long-term key reveal on the server S.

// Not exists Server and Symkey at i and j (temporal) such that
// Client has setup a session key 'symkey' with server 'S' at i and
// the adversary knows 'symkey' at j
// without having performed privkey reveal on 'S' at r 

lemma Client_session_key_secrecy:
    "
    not ( 
        Ex S symkey #i #j . 
            SessionKeyClient(S, symkey) @ #i &
            K(symkey) @ #j &
            not (Ex #r . PrivReveal(S) @ r)
        )
    "





// For all session key 'symkey setup by the client with server 'S'
// Exists a server that answered that request  OR  the adversary performed a privkey reveal on 'S 
// before it was setup (r < i)'

lemma Client_auth:
    "
    (
        All S symkey #i . SessionKeyClient(S, symkey) @ i
            ==>
        (   (Ex #a . AnswerRequest(S, symkey) @ a ) | (Ex #r . PrivReveal(S) @ r  & r < i)   )
    
    )       
    "

// For all session keys 'symkey' setup by client with server 'S'
// Exists a server that answered the request and there is no other client that had the same request (if exists ==> then #i = #j)
// Or the adversary performed a privkey reveal on 'S' before the key was setup (r < i)

lemma Client_auth_injective: // prove Client_auth uniqueness
    "
    (
        All S symkey #i . SessionKeyClient(S,symkey) @ #i
        ==>
        (  
            (Ex #a . AnswerRequest(S,symkey) @ a & (All #j . SessionKeyClient(S,symkey) @ j ==> #i = #j)) | 
            (Ex #r . PrivReveal(S) @ r & r < i)
        )
    )
    "

lemma Client_session_key_honest_setup: // executability lemma
    exists-trace
    "
        Ex S symkey #i . 
            SessionKeyClient(S, symkey) @ i &
            not(Ex #r . PrivReveal(S) @ r) 
    "
end